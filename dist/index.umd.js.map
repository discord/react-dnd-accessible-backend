{"version":3,"file":"index.umd.js","sources":["../src/util/AnnouncementMessages.tsx","../src/DropTargetNavigator.tsx","../src/DragAnnouncer.tsx","../src/DragPreviewer.tsx","../src/util/getNodeClientOffset.tsx","../src/util/stopEvent.tsx","../src/util/FocusManager.tsx","../src/util/isKeyboardDragTrigger.tsx","../src/KeyboardBackend.tsx"],"sourcesContent":["type ItemMessageGetter = (itemId: string, node: HTMLElement | null) => string;\n\nexport interface AnnouncementMessages {\n  pickedUpItem: ItemMessageGetter;\n  droppedItem: ItemMessageGetter;\n  hoveredTarget: ItemMessageGetter;\n  canceledDrag: ItemMessageGetter;\n}\n\nexport function getNodeDescription(node: HTMLElement | null): string | undefined {\n  if (node == null) return undefined;\n\n  return node.getAttribute(\"data-dnd-name\") ?? node.getAttribute(\"aria-label\") ?? node.innerText;\n}\n\nexport const DEFAULT_ANNOUNCEMENT_MESSAGES: AnnouncementMessages = {\n  pickedUpItem: (itemId: string, node: HTMLElement | null) => {\n    const label = getNodeDescription(node) ?? itemId;\n\n    return `Picked up ${label}`;\n  },\n  droppedItem: (itemId: string, node: HTMLElement | null) => {\n    const label = getNodeDescription(node) ?? itemId;\n\n    return `Dropped ${label}`;\n  },\n  hoveredTarget: (targetId: string, node: HTMLElement | null) => {\n    const label = getNodeDescription(node) ?? targetId;\n\n    return `Over ${label}`;\n  },\n  canceledDrag: (itemId: string, node: HTMLElement | null) => {\n    const label = getNodeDescription(node) ?? itemId;\n\n    return `Stopped dragging ${label}`;\n  },\n};\n\nexport function getDefaultAnnouncementMessages() {\n  return DEFAULT_ANNOUNCEMENT_MESSAGES;\n}\n","import type DragAnnouncer from \"./DragAnnouncer\";\nimport type DragPreviewer from \"./DragPreviewer\";\nimport { createFocusManager, FocusManager } from \"./util/FocusManager\";\nimport getNodeClientOffset from \"./util/getNodeClientOffset\";\nimport stopEvent from \"./util/stopEvent\";\n\nimport type { DragDropActions, DragDropManager, DragDropMonitor } from \"dnd-core\";\n\nenum NavigationKeys {\n  UP = \"ArrowUp\",\n  DOWN = \"ArrowDown\",\n  DROP = \"Shift\",\n  CANCEL = \"Escape\",\n}\n\nexport class DropTargetNavigator {\n  private currentHoveredNode: HTMLElement | null;\n  private focusManager: FocusManager;\n  private actions: DragDropActions;\n  private monitor: DragDropMonitor;\n\n  constructor(\n    sourceNode: HTMLElement,\n    private targetNodes: Map<string, HTMLElement>,\n    private manager: DragDropManager,\n    private previewer: DragPreviewer,\n    private announcer: DragAnnouncer,\n  ) {\n    this.currentHoveredNode = sourceNode;\n    this.focusManager = createFocusManager({\n      getFocusableElements: () => this.getViableTargets(targetNodes),\n    });\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n\n    window.addEventListener(\"keydown\", this.handleDraggedElementKeyDown, { capture: true });\n  }\n\n  disconnect() {\n    window.removeEventListener(\"keydown\", this.handleDraggedElementKeyDown, { capture: true });\n  }\n\n  handleDraggedElementKeyDown = (event: KeyboardEvent) => {\n    switch (event.key) {\n      case NavigationKeys.UP:\n        stopEvent(event);\n        this.hoverNode(this.getPreviousDropTarget());\n        return;\n\n      case NavigationKeys.DOWN:\n        stopEvent(event);\n        this.hoverNode(this.getNextDropTarget());\n        return;\n    }\n  };\n\n  hoverNode(node: HTMLElement | null) {\n    const targetId = Array.from(this.targetNodes.entries()).find(\n      ([_key, value]) => node === value,\n    )?.[0];\n    if (targetId == null) return;\n\n    this.actions.hover([targetId], { clientOffset: getNodeClientOffset(node) });\n    this.currentHoveredNode = node;\n    this.previewer.render(this.monitor);\n    this.announcer.announceHover(node, targetId);\n    node?.focus();\n  }\n\n  getNextDropTarget() {\n    return this.focusManager.getNextFocusableElement({\n      wrap: false,\n      from: this.currentHoveredNode ?? undefined,\n    });\n  }\n\n  getPreviousDropTarget() {\n    return this.focusManager.getPreviousFocusableElement({\n      wrap: false,\n      from: this.currentHoveredNode ?? undefined,\n    });\n  }\n\n  getViableTargets(nodes: Map<string, HTMLElement>) {\n    const allowedTargets = this.getAllowedTargets(nodes);\n\n    return allowedTargets.sort((a, b) => {\n      if (a === b) return 0;\n\n      const position = a.compareDocumentPosition(b);\n      if (\n        position &\n        (Node.DOCUMENT_POSITION_FOLLOWING | (position & Node.DOCUMENT_POSITION_CONTAINED_BY))\n      )\n        return -1;\n      else if (\n        position &\n        (Node.DOCUMENT_POSITION_PRECEDING | (position & Node.DOCUMENT_POSITION_CONTAINS))\n      )\n        return 1;\n      else return 0;\n    });\n  }\n\n  getAllowedTargets(nodes: Map<string, HTMLElement>) {\n    const sourceType = this.monitor.getItemType();\n    if (sourceType == null) return Array.from(nodes.values());\n\n    return Array.from(nodes).reduce((acc, [id, node]) => {\n      if (this.manager.getMonitor().canDropOnTarget(id)) acc.push(node);\n      return acc;\n    }, [] as HTMLElement[]);\n  }\n}\n","import { AnnouncementMessages, getDefaultAnnouncementMessages } from \"./util/AnnouncementMessages\";\n\ntype Assertiveness = 'assertive' | 'polite';\nexport interface Announcer {\n  announce(message: string, assertiveness?: Assertiveness, timeout?: number): void;\n  clearAnnouncements(assertiveness?: Assertiveness): void;\n  destroy?(): void;\n}\ninterface AnnouncerOptions {\n  getAnnouncementMessages?: () => AnnouncementMessages;\n  announcer?: Announcer;\n}\n\nexport default class DragAnnouncer {\n  private announcer: Announcer;\n  private externalAnnouncer: boolean;\n  private getMessages: () => AnnouncementMessages;\n\n  public constructor({getAnnouncementMessages, announcer}: AnnouncerOptions = {}) {\n    this.getMessages = getAnnouncementMessages ?? getDefaultAnnouncementMessages;\n    this.externalAnnouncer = false;\n\n    if (announcer != null) {\n      this.announcer = announcer;\n      this.externalAnnouncer = true;\n    } else {\n      const LiveAnnouncer = require('@react-aria/live-announcer');\n      this.announcer = {\n        announce: LiveAnnouncer.announce,\n        clearAnnouncements: LiveAnnouncer.clearAnnouncer,\n        destroy: LiveAnnouncer.destroyAnnouncer,\n      };\n    }\n  }\n\n  announce(message: string, assertiveness?: Assertiveness, timeout?: number) {\n    this.announcer.announce(message, assertiveness, timeout);\n  }\n\n  announceDrag(node: HTMLElement | null, id: string) {\n    if (node == null) return;\n    this.announce(this.getMessages().pickedUpItem(id, node));\n  }\n\n  announceHover(node: HTMLElement | null, id: string) {\n    if (node == null) return;\n    this.announce(this.getMessages().hoveredTarget(id, node));\n  }\n\n  announceDrop(node: HTMLElement | null, id: string) {\n    this.announce(this.getMessages().droppedItem(id, node));\n  }\n\n  announceCancel(node: HTMLElement | null, id: string) {\n    this.announce(this.getMessages().canceledDrag(id, node));\n  }\n\n  clear() {\n    this.announcer.clearAnnouncements();\n  }\n\n  destroy() {\n    // don't destroy an external announcer, since it is likely used outside of drag-and-drop\n    if (!this.externalAnnouncer) {\n      this.announcer.destroy?.();\n    }\n  }\n}\n","import type { DragDropMonitor } from \"dnd-core\";\n\ninterface PreviewerOptions {\n  previewerClassName?: string;\n}\n\nexport default class DragPreview {\n  private container: HTMLElement | undefined;\n  private svg: HTMLElement | undefined;\n  private foreignObject: HTMLElement | undefined;\n\n  public constructor(\n    private document: Document | undefined,\n    { previewerClassName }: PreviewerOptions = {},\n  ) {\n    this.container = this.document?.createElement(\"div\");\n    this.svg = this.document?.createElement(\"svg\");\n    this.foreignObject = this.document?.createElement(\"foreignObject\");\n\n    if (this.container != null && this.svg != null && this.foreignObject != null) {\n      if (previewerClassName) {\n        this.container.className = previewerClassName;\n      } else {\n        this.container.className = \"drag-previewer\";\n        this.container.style.cssText = \"z-index: 1000;\";\n      }\n\n      this.svg.appendChild(this.foreignObject);\n      this.container.appendChild(this.svg);\n    }\n  }\n\n  attach() {\n    if (this.container == null) return;\n    this.document?.body.appendChild(this.container);\n  }\n\n  detach() {\n    const body = this.document?.body;\n    if (this.container == null || body == null) return;\n    if (body.contains(this.container)) {\n      body.removeChild(this.container);\n    }\n  }\n\n  createDragPreview(sourceNode: HTMLElement) {\n    if (this.container == null || this.svg == null || this.foreignObject == null) return;\n\n    const { width, height } = sourceNode.getBoundingClientRect();\n\n    this.svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    this.svg.setAttribute(\"width\", `${width}`);\n    this.svg.setAttribute(\"height\", `${height}`);\n    this.foreignObject.setAttribute(\"x\", \"0\");\n    this.foreignObject.setAttribute(\"y\", \"0\");\n    this.foreignObject.setAttribute(\"width\", `${width}`);\n    this.foreignObject.setAttribute(\"height\", `${height}`);\n\n    const sourceClone = sourceNode.cloneNode(true);\n\n    this.foreignObject.appendChild(sourceClone);\n  }\n\n  render(monitor: DragDropMonitor) {\n    const container = this.container;\n    if (container == null) return;\n\n    const offset = monitor.getSourceClientOffset();\n    if (offset == null) return;\n    if (!monitor.isDragging()) return;\n\n    container.style.position = \"fixed\";\n    container.style.left = `${offset.x + 30}px`;\n    container.style.top = `${offset.y + 15}px`;\n  }\n\n  clear() {\n    if (this.foreignObject == null) return;\n    this.foreignObject.innerHTML = \"\";\n  }\n}\n","import { XYCoord } from \"dnd-core\";\n\nexport default function getNodeClientOffset(node: HTMLElement | null | undefined): XYCoord {\n  if (node == null) return { x: 0, y: 0 };\n\n  const el = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n  if (!el) return { x: 0, y: 0 };\n\n  const { top, left } = el.getBoundingClientRect();\n  return { x: left, y: top };\n}\n","export default function stopEvent(event: KeyboardEvent) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n","export interface FocusManagerOptions {\n  getFocusableElements(): HTMLElement[];\n}\n\nexport interface FocusOptions {\n  wrap?: boolean;\n  from?: HTMLElement;\n}\n\nexport interface FocusManager {\n  getNextFocusableElement(options?: FocusOptions): HTMLElement | null;\n  getPreviousFocusableElement(options?: FocusOptions): HTMLElement | null;\n  getFirstFocusableElement(): HTMLElement | null;\n  getLastFocusableElement(): HTMLElement | null;\n}\n\nexport function createFocusManager({ getFocusableElements }: FocusManagerOptions): FocusManager {\n  function getNextFocusableElement(options?: FocusOptions): HTMLElement | null {\n    const currentTarget = options?.from || document.activeElement;\n    if (currentTarget == null) {\n      return null;\n    }\n    const elements = getFocusableElements();\n    const nextNode = elements.find((element) => {\n      return !!(\n        currentTarget.compareDocumentPosition(element) &\n        (Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY)\n      );\n    });\n    if (nextNode == null && options?.wrap) {\n      return elements[0] ?? null;\n    }\n    return nextNode as HTMLElement;\n  }\n\n  function getPreviousFocusableElement(options?: FocusOptions): HTMLElement | null {\n    const currentTarget = options?.from || document.activeElement;\n    if (currentTarget == null) {\n      return null;\n    }\n    const elements = getFocusableElements();\n    for (let i = elements.length - 1; i >= 0; i--) {\n      const element = elements[i];\n      if (\n        currentTarget.compareDocumentPosition(element) &\n        (Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINED_BY)\n      ) {\n        return element as HTMLElement;\n      }\n    }\n    if (options?.wrap) {\n      return elements[elements.length - 1] ?? null;\n    }\n    return null;\n  }\n\n  function getFirstFocusableElement(): HTMLElement | null {\n    const elements = getFocusableElements();\n    return elements[0] ?? null;\n  }\n\n  function getLastFocusableElement(): HTMLElement | null {\n    const elements = getFocusableElements();\n    return elements[elements.length - 1] ?? null;\n  }\n\n  return {\n    getNextFocusableElement,\n    getPreviousFocusableElement,\n    getFirstFocusableElement,\n    getLastFocusableElement,\n  };\n}\n","export default function isKeyboardDragTrigger(\n  event: KeyboardEvent,\n  withUntrusted: boolean = false,\n) {\n  // VERY HACK(faulty): react-dnd-multi-backend fires a \"cloned event\" after\n  // transitioning backends. But, that event is only a base Event, not a specialized\n  // KeyboardEvent or MouseEvent, so it doesn't have any of the `.key`, `.metaKey`,\n  // etc. properties on it. Because of that, knowing that this is a trigger can\n  // only be done by looking at the `isTrusted` property, which is false for\n  // custom-constructed events. Eventually, rdmb should fire an appropriate event instead.\n  if (withUntrusted && event.isTrusted === false) return true;\n  return event.key?.toLowerCase() === \"d\" && (event.metaKey || event.ctrlKey) && !event.altKey;\n}\n","import DragAnnouncer from \"./DragAnnouncer\";\nimport DragPreviewer from \"./DragPreviewer\";\nimport { DropTargetNavigator } from \"./DropTargetNavigator\";\nimport getNodeClientOffset from \"./util/getNodeClientOffset\";\nimport isKeyboardDragTrigger from \"./util/isKeyboardDragTrigger\";\nimport stopEvent from \"./util/stopEvent\";\n\nimport type {Announcer} from \"./DragAnnouncer\";\nimport type {\n  Backend,\n  BackendFactory,\n  DragDropActions,\n  DragDropMonitor,\n  Identifier,\n  DragDropManager,\n  Unsubscribe,\n} from \"dnd-core\";\nimport type { AnnouncementMessages } from \"./util/AnnouncementMessages\";\n\nconst Trigger = {\n  DROP: [\" \", \"Enter\"],\n  CANCEL_DRAG: [\"Escape\"],\n};\n\nfunction isTrigger(event: KeyboardEvent, trigger: typeof Trigger[keyof typeof Trigger]) {\n  return trigger.includes(event.key);\n}\n\ninterface KeyboardBackendContext {\n  window?: Window;\n  document?: Document;\n}\n\ninterface KeyboardBackendOptions {\n  onDndModeChanged?: (enabled: boolean) => unknown;\n  isDragTrigger?: (event: KeyboardEvent, isFirstEvent: boolean) => boolean;\n  getAnnouncementMessages?: () => AnnouncementMessages;\n  announcer?: Announcer;\n  previewerClassName?: string;\n}\n\nexport class KeyboardBackend implements Backend {\n  private static isSetUp: boolean;\n  // React-DnD Dependencies\n  private manager: DragDropManager;\n  private actions: DragDropActions;\n  private monitor: DragDropMonitor;\n  private context: KeyboardBackendContext;\n  private options?: KeyboardBackendOptions;\n  // Internal State\n  private sourceNodes: Map<Identifier, HTMLElement>;\n  private sourcePreviewNodes: Map<string, HTMLElement>;\n  private sourcePreviewNodeOptions: Map<string, any>;\n  private targetNodes: Map<string, HTMLElement>;\n  private _navigator: DropTargetNavigator | undefined;\n  public _previewer: DragPreviewer;\n  private _announcer: DragAnnouncer;\n  private _isDragTrigger: (event: KeyboardEvent, isFirstEvent: boolean) => boolean;\n  private _handlingFirstEvent: boolean = false;\n\n  public constructor(\n    manager: DragDropManager,\n    context: KeyboardBackendContext,\n    options?: KeyboardBackendOptions,\n  ) {\n    this.manager = manager;\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.context = context;\n    this.options = options;\n    this._isDragTrigger = options?.isDragTrigger ?? isKeyboardDragTrigger;\n\n    this.sourceNodes = new Map();\n    this.sourcePreviewNodes = new Map();\n    this.sourcePreviewNodeOptions = new Map();\n    this.targetNodes = new Map();\n\n    this._previewer = new DragPreviewer(context.document, options);\n    this._announcer = new DragAnnouncer(options);\n  }\n\n  public setup() {\n    if (KeyboardBackend.isSetUp) {\n      throw new Error(\"Cannot have two Keyboard backends at the same time.\");\n    }\n    KeyboardBackend.isSetUp = true;\n\n    this._handlingFirstEvent = true;\n    this.context.window?.addEventListener(\"keydown\", this.handleGlobalKeyDown, { capture: true });\n\n    this._previewer.attach();\n  }\n\n  public teardown() {\n    KeyboardBackend.isSetUp = false;\n    this.context.window?.removeEventListener(\"keydown\", this.handleGlobalKeyDown, {\n      capture: true,\n    });\n    this.endDrag();\n\n    this._previewer.detach();\n    this._announcer.destroy();\n  }\n\n  private handleGlobalKeyDown = (event: KeyboardEvent) => {\n    if (this.monitor.isDragging() && isTrigger(event, Trigger.CANCEL_DRAG)) {\n      this.endDrag(event);\n      const sourceId = String(this.monitor.getSourceId());\n      const sourceNode = this.sourceNodes.get(sourceId);\n      this._announcer.announceCancel(sourceNode ?? null, sourceId);\n    }\n  };\n\n  private setDndMode(enabled: boolean) {\n    this.options?.onDndModeChanged?.(enabled);\n  }\n\n  public profile(): Record<string, number> {\n    return {\n      sourcePreviewNodes: this.sourcePreviewNodes.size,\n      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n      sourceNodes: this.sourceNodes.size,\n    };\n  }\n\n  public connectDragSource(sourceId: string, node: HTMLElement): Unsubscribe {\n    const handleDragStart = this.handleDragStart.bind(this, sourceId);\n\n    this.sourceNodes.set(sourceId, node);\n    node.addEventListener(\"keydown\", handleDragStart);\n    return () => {\n      this.sourceNodes.delete(sourceId);\n      node.removeEventListener(\"keydown\", handleDragStart);\n    };\n  }\n\n  public connectDragPreview(sourceId: string, node: HTMLElement, options: any): Unsubscribe {\n    this.sourcePreviewNodeOptions.set(sourceId, options);\n    this.sourcePreviewNodes.set(sourceId, node);\n    return () => {\n      this.sourcePreviewNodes.delete(sourceId);\n      this.sourcePreviewNodeOptions.delete(sourceId);\n    };\n  }\n\n  public connectDropTarget(targetId: string, node: HTMLElement): Unsubscribe {\n    this.targetNodes.set(targetId, node);\n    node.addEventListener(\"keydown\", this.handleDrop);\n    // Ensure that the target will be focusable by the navigator\n    node.tabIndex = Math.max(-1, node.tabIndex);\n\n    return () => {\n      this.targetNodes.delete(targetId);\n      node.removeEventListener(\"keydown\", this.handleDrop);\n    };\n  }\n\n  private getSourceClientOffset = (sourceId: string) => {\n    return getNodeClientOffset(this.sourceNodes.get(sourceId));\n  };\n\n  private handleDragStart = (sourceId: string, event: KeyboardEvent) => {\n    if (!this._isDragTrigger(event, this._handlingFirstEvent)) return;\n    this._handlingFirstEvent = false;\n\n    if (!this.monitor.canDragSource(sourceId)) return;\n\n    if (this.monitor.isDragging()) {\n      this.actions.publishDragSource();\n      return;\n    }\n\n    stopEvent(event);\n\n    const sourceNode = this.sourceNodes.get(sourceId);\n    if (sourceNode == null) return;\n\n    this._navigator = new DropTargetNavigator(\n      sourceNode,\n      this.targetNodes,\n      this.manager,\n      this._previewer,\n      this._announcer,\n    );\n    this._previewer.createDragPreview(this.sourcePreviewNodes.get(sourceId) ?? sourceNode);\n\n    this.actions.beginDrag([sourceId], {\n      clientOffset: this.getSourceClientOffset(sourceId),\n      getSourceClientOffset: this.getSourceClientOffset,\n      publishSource: false,\n    });\n    this._previewer.render(this.monitor);\n    this.setDndMode(true);\n    this._announcer.announceDrag(sourceNode, sourceId);\n  };\n\n  private handleDrop = (event: KeyboardEvent) => {\n    if (!isTrigger(event, Trigger.DROP)) return;\n\n    const sourceId = String(this.monitor.getSourceId());\n    const sourceNode = this.sourceNodes.get(sourceId);\n    this._announcer.announceDrop(sourceNode ?? null, sourceId);\n\n    this.actions.drop();\n    this.endDrag(event);\n  };\n\n  private endDrag(event?: KeyboardEvent) {\n    event != null && stopEvent(event);\n    this._navigator?.disconnect();\n    this._previewer.clear();\n    if (this.monitor.isDragging()) this.actions.endDrag();\n    this.setDndMode(false);\n  }\n}\n\nconst createKeyboardBackendFactory: BackendFactory = (\n  manager: DragDropManager,\n  context: KeyboardBackendContext,\n  options?: KeyboardBackendOptions,\n) => new KeyboardBackend(manager, context, options);\n\nexport default createKeyboardBackendFactory;\n"],"names":["getNodeDescription","node","getAttribute","innerText","DEFAULT_ANNOUNCEMENT_MESSAGES","pickedUpItem","itemId","droppedItem","hoveredTarget","targetId","canceledDrag","getDefaultAnnouncementMessages","NavigationKeys","DragAnnouncer","getAnnouncementMessages","announcer","externalAnnouncer","getMessages","this","LiveAnnouncer","require","announce","clearAnnouncements","clearAnnouncer","destroy","destroyAnnouncer","message","assertiveness","timeout","announceDrag","id","announceHover","announceDrop","announceCancel","clear","DragPreview","document","previewerClassName","container","svg","foreignObject","_this$document","createElement","_this$document2","_this$document3","className","style","cssText","appendChild","attach","body","detach","_this$document5","contains","removeChild","createDragPreview","sourceNode","getBoundingClientRect","width","height","setAttribute","sourceClone","cloneNode","render","monitor","offset","getSourceClientOffset","isDragging","position","left","x","top","y","innerHTML","getNodeClientOffset","el","nodeType","Node","ELEMENT_NODE","parentElement","stopEvent","event","preventDefault","stopImmediatePropagation","DropTargetNavigator","targetNodes","manager","previewer","getFocusableElements","currentHoveredNode","focusManager","actions","handleDraggedElementKeyDown","key","UP","_this","hoverNode","getPreviousDropTarget","DOWN","getNextDropTarget","getViableTargets","getNextFocusableElement","options","currentTarget","from","activeElement","elements","nextNode","find","element","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_CONTAINED_BY","wrap","getPreviousFocusableElement","i","length","DOCUMENT_POSITION_PRECEDING","getFirstFocusableElement","getLastFocusableElement","getActions","getMonitor","window","addEventListener","capture","disconnect","removeEventListener","Array","entries","_Array$from$find","hover","clientOffset","focus","undefined","nodes","getAllowedTargets","sort","a","b","DOCUMENT_POSITION_CONTAINS","getItemType","values","reduce","acc","_this2","canDropOnTarget","push","isKeyboardDragTrigger","withUntrusted","isTrusted","toLowerCase","metaKey","ctrlKey","altKey","Trigger","isTrigger","trigger","includes","KeyboardBackend","context","sourceNodes","sourcePreviewNodes","sourcePreviewNodeOptions","_navigator","_previewer","_announcer","_isDragTrigger","_handlingFirstEvent","handleGlobalKeyDown","endDrag","sourceId","String","getSourceId","get","handleDragStart","canDragSource","publishDragSource","beginDrag","publishSource","setDndMode","handleDrop","drop","isDragTrigger","Map","DragPreviewer","setup","isSetUp","Error","teardown","enabled","onDndModeChanged","profile","size","connectDragSource","bind","set","connectDragPreview","_this3","connectDropTarget","tabIndex","Math","max","_this4"],"mappings":"4PASgBA,EAAmBC,WACjC,GAAY,MAARA,EAEJ,yBAAOA,EAAKC,aAAa,oBAAoBD,EAAKC,aAAa,iBAAiBD,EAAKE,cAG1EC,EAAsD,CACjEC,aAAc,SAACC,EAAgBL,SAG7B,6BAFcD,EAAmBC,MAASK,IAI5CC,YAAa,SAACD,EAAgBL,SAG5B,2BAFcD,EAAmBC,MAASK,IAI5CE,cAAe,SAACC,EAAkBR,SAGhC,wBAFcD,EAAmBC,MAASQ,IAI5CC,aAAc,SAACJ,EAAgBL,SAG7B,oCAFcD,EAAmBC,MAASK,cAM9BK,IACd,OAAOP,MC/BJQ,ECKgBC,aAKnB,+BAA4E,KAAxDC,IAAAA,wBAAyBC,IAAAA,UAI3C,QARMA,sBACAC,8BACAC,mBAGNC,KAAKD,kBAAcH,EAAAA,EAA2BH,EAC9CO,KAAKF,mBAAoB,EAER,MAAbD,EACFG,KAAKH,UAAYA,EACjBG,KAAKF,mBAAoB,MACpB,CACL,IAAMG,EAAgBC,QAAQ,8BAC9BF,KAAKH,UAAY,CACfM,SAAUF,EAAcE,SACxBC,mBAAoBH,EAAcI,eAClCC,QAASL,EAAcM,8CAK7BJ,SAAA,SAASK,EAAiBC,EAA+BC,GACvDV,KAAKH,UAAUM,SAASK,EAASC,EAAeC,MAGlDC,aAAA,SAAa5B,EAA0B6B,GACzB,MAAR7B,GACJiB,KAAKG,SAASH,KAAKD,cAAcZ,aAAayB,EAAI7B,OAGpD8B,cAAA,SAAc9B,EAA0B6B,GAC1B,MAAR7B,GACJiB,KAAKG,SAASH,KAAKD,cAAcT,cAAcsB,EAAI7B,OAGrD+B,aAAA,SAAa/B,EAA0B6B,GACrCZ,KAAKG,SAASH,KAAKD,cAAcV,YAAYuB,EAAI7B,OAGnDgC,eAAA,SAAehC,EAA0B6B,GACvCZ,KAAKG,SAASH,KAAKD,cAAcP,aAAaoB,EAAI7B,OAGpDiC,MAAA,WACEhB,KAAKH,UAAUO,wBAGjBE,QAAA,mBAEON,KAAKF,oCACHD,WAAUS,0BC1DAW,aAKnB,WACUC,eACNC,cAAyC,MAAzCA,wBADMD,qBALFE,sBACAC,gBACAC,qBAGEtB,cAAAkB,EAGRlB,KAAKoB,mBAAYpB,KAAKkB,iBAALK,EAAeC,cAAc,OAC9CxB,KAAKqB,aAAMrB,KAAKkB,iBAALO,EAAeD,cAAc,OACxCxB,KAAKsB,uBAAgBtB,KAAKkB,iBAALQ,EAAeF,cAAc,iBAE5B,MAAlBxB,KAAKoB,WAAiC,MAAZpB,KAAKqB,KAAqC,MAAtBrB,KAAKsB,gBACjDH,EACFnB,KAAKoB,UAAUO,UAAYR,GAE3BnB,KAAKoB,UAAUO,UAAY,iBAC3B3B,KAAKoB,UAAUQ,MAAMC,QAAU,kBAGjC7B,KAAKqB,IAAIS,YAAY9B,KAAKsB,eAC1BtB,KAAKoB,UAAUU,YAAY9B,KAAKqB,iCAIpCU,OAAA,iBACwB,MAAlB/B,KAAKoB,0BACJF,aAAUc,KAAKF,YAAY9B,KAAKoB,eAGvCa,OAAA,iBACQD,WAAOhC,KAAKkB,iBAALgB,EAAeF,KACN,MAAlBhC,KAAKoB,WAA6B,MAARY,GAC1BA,EAAKG,SAASnC,KAAKoB,YACrBY,EAAKI,YAAYpC,KAAKoB,cAI1BiB,kBAAA,SAAkBC,GAChB,GAAsB,MAAlBtC,KAAKoB,WAAiC,MAAZpB,KAAKqB,KAAqC,MAAtBrB,KAAKsB,cAAvD,CAEA,MAA0BgB,EAAWC,wBAA7BC,IAAAA,MAAOC,IAAAA,OAEfzC,KAAKqB,IAAIqB,aAAa,iBAAkBF,MAASC,GACjDzC,KAAKqB,IAAIqB,aAAa,WAAYF,GAClCxC,KAAKqB,IAAIqB,aAAa,YAAaD,GACnCzC,KAAKsB,cAAcoB,aAAa,IAAK,KACrC1C,KAAKsB,cAAcoB,aAAa,IAAK,KACrC1C,KAAKsB,cAAcoB,aAAa,WAAYF,GAC5CxC,KAAKsB,cAAcoB,aAAa,YAAaD,GAE7C,IAAME,EAAcL,EAAWM,WAAU,GAEzC5C,KAAKsB,cAAcQ,YAAYa,OAGjCE,OAAA,SAAOC,GACL,IAAM1B,EAAYpB,KAAKoB,UACvB,GAAiB,MAAbA,EAAJ,CAEA,IAAM2B,EAASD,EAAQE,wBACT,MAAVD,GACCD,EAAQG,eAEb7B,EAAUQ,MAAMsB,SAAW,QAC3B9B,EAAUQ,MAAMuB,KAAUJ,EAAOK,EAAI,QACrChC,EAAUQ,MAAMyB,IAASN,EAAOO,EAAI,aAGtCtC,MAAA,WAC4B,MAAtBhB,KAAKsB,gBACTtB,KAAKsB,cAAciC,UAAY,mBC5EXC,EAAoBzE,GAC1C,GAAY,MAARA,EAAc,MAAO,CAAEqE,EAAG,EAAGE,EAAG,GAEpC,IAAMG,EAAK1E,EAAK2E,WAAaC,KAAKC,aAAe7E,EAAOA,EAAK8E,cAC7D,IAAKJ,EAAI,MAAO,CAAEL,EAAG,EAAGE,EAAG,GAE3B,MAAsBG,EAAGlB,wBACzB,MAAO,CAAEa,IADID,KACKG,IADVD,cCRcS,EAAUC,GAChCA,EAAMC,iBACND,EAAME,4BJMR,SAAKvE,GACHA,eACAA,mBACAA,eACAA,kBAJF,CAAKA,IAAAA,WAOQwE,aAMX,WACE5B,EACQ6B,EACAC,EACAC,EACAxE,OKVyByE,cLOzBH,wBACAC,oBACAC,sBACAxE,sBAVF0E,+BACAC,yBACAC,oBACA3B,oBAuBR4B,4BAA8B,SAACX,GAC7B,OAAQA,EAAMY,KACZ,KAAKjF,EAAekF,GAGlB,OAFAd,EAAUC,QACVc,EAAKC,UAAUD,EAAKE,yBAGtB,KAAKrF,EAAesF,KAGlB,OAFAlB,EAAUC,QACVc,EAAKC,UAAUD,EAAKI,uBA5BhBjF,iBAAAmE,EACAnE,aAAAoE,EACApE,eAAAqE,EACArE,eAAAH,EAERG,KAAKuE,mBAAqBjC,EAC1BtC,KAAKwE,cKb4BF,ELcT,kBAAMO,EAAKK,iBAAiBf,IKoC/C,CACLgB,wBAlDF,SAAiCC,GAC/B,IAAMC,SAAgBD,SAAAA,EAASE,OAAQpE,SAASqE,cAChD,GAAqB,MAAjBF,EACF,YAEF,MAAMG,EAAWlB,IACXmB,EAAWD,EAASE,KAAK,SAACC,GAC9B,SACEN,EAAcO,wBAAwBD,IACrChC,KAAKkC,4BAA8BlC,KAAKmC,mCAG7C,OAAgB,MAAZL,SAAoBL,GAAAA,EAASW,cACxBP,EAAS,MAAM,KAEjBC,GAoCPO,4BAjCF,SAAqCZ,GACnC,IAAMC,SAAgBD,SAAAA,EAASE,OAAQpE,SAASqE,cAChD,GAAqB,MAAjBF,EACF,YAGF,IADA,MAAMG,EAAWlB,IACR2B,EAAIT,EAASU,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC7C,IAAMN,EAAUH,EAASS,GACzB,GACEZ,EAAcO,wBAAwBD,IACrChC,KAAKwC,4BAA8BxC,KAAKmC,gCAEzC,OAAOH,EAGX,aAAIP,GAAAA,EAASW,eACJP,EAASA,EAASU,OAAS,YAkBpCE,yBAbF,iBAEE,gBADiB9B,IACD,MAAM,MAYtB+B,wBATF,iBACQb,EAAWlB,IACjB,gBAAOkB,EAASA,EAASU,OAAS,MAAM,QL/BxClG,KAAKyE,QAAUL,EAAQkC,aACvBtG,KAAK8C,QAAUsB,EAAQmC,aAEvBC,OAAOC,iBAAiB,UAAWzG,KAAK0E,4BAA6B,CAAEgC,SAAS,IApBpF,2BAuBEC,WAAA,WACEH,OAAOI,oBAAoB,UAAW5G,KAAK0E,4BAA6B,CAAEgC,SAAS,OAiBrF5B,UAAA,SAAU/F,SACFQ,WAAWsH,MAAMvB,KAAKtF,KAAKmE,YAAY2C,WAAWpB,KACtD,mBAAmB3G,mBADJgI,EAEb,GACY,MAAZxH,IAEJS,KAAKyE,QAAQuC,MAAM,CAACzH,GAAW,CAAE0H,aAAczD,EAAoBzE,KACnEiB,KAAKuE,mBAAqBxF,EAC1BiB,KAAKqE,UAAUxB,OAAO7C,KAAK8C,SAC3B9C,KAAKH,UAAUgB,cAAc9B,EAAMQ,SACnCR,GAAAA,EAAMmI,YAGRjC,kBAAA,iBACE,YAAYT,aAAaW,wBAAwB,CAC/CY,MAAM,EACNT,cAAMtF,KAAKuE,2BAAsB4C,OAIrCpC,sBAAA,iBACE,YAAYP,aAAawB,4BAA4B,CACnDD,MAAM,EACNT,cAAMtF,KAAKuE,2BAAsB4C,OAIrCjC,iBAAA,SAAiBkC,GAGf,OAFuBpH,KAAKqH,kBAAkBD,GAExBE,KAAK,SAACC,EAAGC,GAC7B,GAAID,IAAMC,EAAG,SAEb,IAAMtE,EAAWqE,EAAE3B,wBAAwB4B,GAC3C,OACEtE,GACCS,KAAKkC,4BAA+B3C,EAAWS,KAAKmC,iCAE7C,EAER5C,GACCS,KAAKwC,4BAA+BjD,EAAWS,KAAK8D,qCAO3DJ,kBAAA,SAAkBD,cAEhB,OAAkB,MADCpH,KAAK8C,QAAQ4E,cACDb,MAAMvB,KAAK8B,EAAMO,UAEzCd,MAAMvB,KAAK8B,GAAOQ,OAAO,SAACC,SAAMjH,OAAI7B,OAEzC,OADI+I,EAAK1D,QAAQmC,aAAawB,gBAAgBnH,IAAKiH,EAAIG,KAAKjJ,GACrD8I,GACN,mBM/GiBI,EACtBlE,EACAmE,SAQA,gBARAA,IAAAA,GAAyB,MAQrBA,IAAqC,IAApBnE,EAAMoE,YACS,gBAA7BpE,EAAMY,cAAKyD,iBAA0BrE,EAAMsE,SAAWtE,EAAMuE,WAAavE,EAAMwE,OCQxF,IAAMC,EACE,CAAC,IAAK,SADRA,EAES,CAAC,UAGhB,SAASC,EAAU1E,EAAsB2E,GACvC,OAAOA,EAAQC,SAAS5E,EAAMY,KAgBnBiE,IAAAA,aAmBX,WACExE,EACAyE,EACAzD,qBAnBMhB,oBACAK,oBACA3B,oBACA+F,oBACAzD,oBAEA0D,wBACAC,+BACAC,qCACA7E,wBACA8E,uBACDC,uBACCC,uBACAC,2BACAC,qBAA+B,OA8C/BC,oBAAsB,SAACvF,GAC7B,GAAIc,EAAK/B,QAAQG,cAAgBwF,EAAU1E,EAAOyE,GAAsB,CACtE3D,EAAK0E,QAAQxF,GACb,IAAMyF,EAAWC,OAAO5E,EAAK/B,QAAQ4G,eAC/BpH,EAAauC,EAAKiE,YAAYa,IAAIH,GACxC3E,EAAKsE,WAAWpI,qBAAeuB,EAAAA,EAAc,KAAMkH,UAgD/CxG,sBAAwB,SAACwG,GAC/B,OAAOhG,EAAoBqB,EAAKiE,YAAYa,IAAIH,UAG1CI,gBAAkB,SAACJ,EAAkBzF,SAC3C,GAAKc,EAAKuE,eAAerF,EAAOc,EAAKwE,uBACrCxE,EAAKwE,qBAAsB,EAEtBxE,EAAK/B,QAAQ+G,cAAcL,IAEhC,GAAI3E,EAAK/B,QAAQG,aACf4B,EAAKJ,QAAQqF,wBADf,CAKAhG,EAAUC,GAEV,IAAMzB,EAAauC,EAAKiE,YAAYa,IAAIH,GACtB,MAAdlH,IAEJuC,EAAKoE,WAAa,IAAI/E,EACpB5B,EACAuC,EAAKV,YACLU,EAAKT,QACLS,EAAKqE,WACLrE,EAAKsE,YAEPtE,EAAKqE,WAAW7G,2BAAkBwC,EAAKkE,mBAAmBY,IAAIH,MAAalH,GAE3EuC,EAAKJ,QAAQsF,UAAU,CAACP,GAAW,CACjCvC,aAAcpC,EAAK7B,sBAAsBwG,GACzCxG,sBAAuB6B,EAAK7B,sBAC5BgH,eAAe,IAEjBnF,EAAKqE,WAAWrG,OAAOgC,EAAK/B,SAC5B+B,EAAKoF,YAAW,GAChBpF,EAAKsE,WAAWxI,aAAa2B,EAAYkH,WAGnCU,WAAa,SAACnG,GACpB,GAAK0E,EAAU1E,EAAOyE,GAAtB,CAEA,IAAMgB,EAAWC,OAAO5E,EAAK/B,QAAQ4G,eAC/BpH,EAAauC,EAAKiE,YAAYa,IAAIH,GACxC3E,EAAKsE,WAAWrI,mBAAawB,EAAAA,EAAc,KAAMkH,GAEjD3E,EAAKJ,QAAQ0F,OACbtF,EAAK0E,QAAQxF,KA3Ib/D,KAAKoE,QAAUA,EACfpE,KAAKyE,QAAUL,EAAQkC,aACvBtG,KAAK8C,QAAUsB,EAAQmC,aACvBvG,KAAK6I,QAAUA,EACf7I,KAAKoF,QAAUA,EACfpF,KAAKoJ,8BAAiBhE,SAAAA,EAASgF,iBAAiBnC,EAEhDjI,KAAK8I,YAAc,IAAIuB,IACvBrK,KAAK+I,mBAAqB,IAAIsB,IAC9BrK,KAAKgJ,yBAA2B,IAAIqB,IACpCrK,KAAKmE,YAAc,IAAIkG,IAEvBrK,KAAKkJ,WAAa,IAAIoB,EAAczB,EAAQ3H,SAAUkE,GACtDpF,KAAKmJ,WAAa,IAAIxJ,EAAcyF,GArCxC,2BAwCSmF,MAAA,iBACL,GAAI3B,EAAgB4B,QAClB,UAAUC,MAAM,uDAElB7B,EAAgB4B,SAAU,EAE1BxK,KAAKqJ,qBAAsB,gBACtBR,QAAQrC,WAAQC,iBAAiB,UAAWzG,KAAKsJ,oBAAqB,CAAE5C,SAAS,IAEtF1G,KAAKkJ,WAAWnH,YAGX2I,SAAA,iBACL9B,EAAgB4B,SAAU,gBACrB3B,QAAQrC,WAAQI,oBAAoB,UAAW5G,KAAKsJ,oBAAqB,CAC5E5C,SAAS,IAEX1G,KAAKuJ,UAELvJ,KAAKkJ,WAAWjH,SAChBjC,KAAKmJ,WAAW7I,aAYV2J,WAAA,SAAWU,uBACZvF,kBAASwF,oBAAAA,iBAAmBD,MAG5BE,QAAA,WACL,MAAO,CACL9B,mBAAoB/I,KAAK+I,mBAAmB+B,KAC5C9B,yBAA0BhJ,KAAKgJ,yBAAyB8B,KACxDhC,YAAa9I,KAAK8I,YAAYgC,SAI3BC,kBAAA,SAAkBvB,EAAkBzK,cACnC6K,EAAkB5J,KAAK4J,gBAAgBoB,KAAKhL,KAAMwJ,GAIxD,OAFAxJ,KAAK8I,YAAYmC,IAAIzB,EAAUzK,GAC/BA,EAAK0H,iBAAiB,UAAWmD,cAE/B9B,EAAKgB,mBAAmBU,GACxBzK,EAAK6H,oBAAoB,UAAWgD,OAIjCsB,mBAAA,SAAmB1B,EAAkBzK,EAAmBqG,cAG7D,OAFApF,KAAKgJ,yBAAyBiC,IAAIzB,EAAUpE,GAC5CpF,KAAK+I,mBAAmBkC,IAAIzB,EAAUzK,cAEpCoM,EAAKpC,0BAA0BS,GAC/B2B,EAAKnC,gCAAgCQ,OAIlC4B,kBAAA,SAAkB7L,EAAkBR,cAMzC,OALAiB,KAAKmE,YAAY8G,IAAI1L,EAAUR,GAC/BA,EAAK0H,iBAAiB,UAAWzG,KAAKkK,YAEtCnL,EAAKsM,SAAWC,KAAKC,KAAK,EAAGxM,EAAKsM,qBAGhCG,EAAKrH,mBAAmB5E,GACxBR,EAAK6H,oBAAoB,UAAW4E,EAAKtB,gBAsDrCX,QAAA,SAAQxF,SACL,MAATA,GAAiBD,EAAUC,iBACtBkF,eAAYtC,aACjB3G,KAAKkJ,WAAWlI,QACZhB,KAAK8C,QAAQG,cAAcjD,KAAKyE,QAAQ8E,UAC5CvJ,KAAKiK,YAAW,SA3KPrB,EACI4B,6CA8KoC,SACnDpG,EACAyE,EACAzD,cACOwD,EAAgBxE,EAASyE,EAASzD"}