{"version":3,"file":"index.modern.js","sources":["../src/util/AnnouncementMessages.tsx","../src/DragAnnouncer.tsx","../src/DragPreviewer.tsx","../src/util/getNodeClientOffset.tsx","../src/util/stopEvent.tsx","../src/DropTargetNavigator.tsx","../src/util/FocusManager.tsx","../src/util/isKeyboardDragTrigger.tsx","../src/KeyboardBackend.tsx"],"sourcesContent":["type ItemMessageGetter = (itemId: string, node: HTMLElement | null) => string;\n\nexport interface AnnouncementMessages {\n  pickedUpItem: ItemMessageGetter;\n  droppedItem: ItemMessageGetter;\n  hoveredTarget: ItemMessageGetter;\n  canceledDrag: ItemMessageGetter;\n}\n\nfunction getNodeDescription(node: HTMLElement | null): string | undefined {\n  if (node == null) return undefined;\n\n  return node.getAttribute(\"data-dnd-name\") ?? node.getAttribute(\"aria-label\") ?? node.innerText;\n}\n\nexport const DEFAULT_ANNOUNCEMENT_MESSAGES: AnnouncementMessages = {\n  pickedUpItem: (itemId: string, node: HTMLElement | null) => {\n    const label = getNodeDescription(node) ?? itemId;\n\n    return `Picked up ${label}`;\n  },\n  droppedItem: (itemId: string, node: HTMLElement | null) => {\n    const label = getNodeDescription(node) ?? itemId;\n\n    return `Dropped ${label}`;\n  },\n  hoveredTarget: (targetId: string, node: HTMLElement | null) => {\n    const label = getNodeDescription(node) ?? targetId;\n\n    return `Over ${label}`;\n  },\n  canceledDrag: (itemId: string, node: HTMLElement | null) => {\n    const label = getNodeDescription(node) ?? itemId;\n\n    return `Stopped dragging ${label}`;\n  },\n};\n\nexport function getDefaultAnnouncementMessages() {\n  return DEFAULT_ANNOUNCEMENT_MESSAGES;\n}\n","import { AnnouncementMessages, getDefaultAnnouncementMessages } from \"./util/AnnouncementMessages\";\n\ntype Assertiveness = 'assertive' | 'polite';\nexport interface Announcer {\n  announce(message: string, assertiveness?: Assertiveness, timeout?: number): void;\n  clearAnnouncements(assertiveness?: Assertiveness): void;\n  destroy?(): void;\n}\ninterface AnnouncerOptions {\n  getAnnouncementMessages?: () => AnnouncementMessages;\n  announcer?: Announcer;\n}\n\nexport default class DragAnnouncer {\n  private announcer: Announcer;\n  private externalAnnouncer: boolean;\n  private getMessages: () => AnnouncementMessages;\n\n  public constructor({getAnnouncementMessages, announcer}: AnnouncerOptions = {}) {\n    this.getMessages = getAnnouncementMessages ?? getDefaultAnnouncementMessages;\n    this.externalAnnouncer = false;\n\n    if (announcer != null) {\n      this.announcer = announcer;\n      this.externalAnnouncer = true;\n    } else {\n      const LiveAnnouncer = require('@react-aria/live-announcer');\n      this.announcer = {\n        announce: LiveAnnouncer.announce,\n        clearAnnouncements: LiveAnnouncer.clearAnnouncer,\n        destroy: LiveAnnouncer.destroyAnnouncer,\n      };\n    }\n  }\n\n  announce(message: string, assertiveness?: Assertiveness, timeout?: number) {\n    this.announcer.announce(message, assertiveness, timeout);\n  }\n\n  announceDrag(node: HTMLElement | null, id: string) {\n    if (node == null) return;\n    this.announce(this.getMessages().pickedUpItem(id, node));\n  }\n\n  announceHover(node: HTMLElement | null, id: string) {\n    if (node == null) return;\n    this.announce(this.getMessages().hoveredTarget(id, node));\n  }\n\n  announceDrop(node: HTMLElement | null, id: string) {\n    this.announce(this.getMessages().droppedItem(id, node));\n  }\n\n  announceCancel(node: HTMLElement | null, id: string) {\n    this.announce(this.getMessages().canceledDrag(id, node));\n  }\n\n  clear() {\n    this.announcer.clearAnnouncements();\n  }\n\n  destroy() {\n    // don't destroy an external announcer, since it is likely used outside of drag-and-drop\n    if (!this.externalAnnouncer) {\n      this.announcer.destroy?.();\n    }\n  }\n}\n","import type { DragDropMonitor } from \"dnd-core\";\n\ninterface PreviewerOptions {\n  previewerClassName?: string;\n}\n\nexport default class DragPreview {\n  private container: HTMLElement | undefined;\n  private svg: HTMLElement | undefined;\n  private foreignObject: HTMLElement | undefined;\n\n  public constructor(\n    private document: Document | undefined,\n    { previewerClassName }: PreviewerOptions = {},\n  ) {\n    this.container = this.document?.createElement(\"div\");\n    this.svg = this.document?.createElement(\"svg\");\n    this.foreignObject = this.document?.createElement(\"foreignObject\");\n\n    if (this.container != null && this.svg != null && this.foreignObject != null) {\n      if (previewerClassName) {\n        this.container.className = previewerClassName;\n      } else {\n        this.container.className = \"drag-previewer\";\n        this.container.style.cssText = \"z-index: 1000;\";\n      }\n\n      this.svg.appendChild(this.foreignObject);\n      this.container.appendChild(this.svg);\n    }\n  }\n\n  attach() {\n    if (this.container == null) return;\n    this.document?.body.appendChild(this.container);\n  }\n\n  detach() {\n    const body = this.document?.body;\n    if (this.container == null || body == null) return;\n    if (body.contains(this.container)) {\n      body.removeChild(this.container);\n    }\n  }\n\n  createDragPreview(sourceNode: HTMLElement) {\n    if (this.container == null || this.svg == null || this.foreignObject == null) return;\n\n    const { width, height } = sourceNode.getBoundingClientRect();\n\n    this.svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    this.svg.setAttribute(\"width\", `${width}`);\n    this.svg.setAttribute(\"height\", `${height}`);\n    this.foreignObject.setAttribute(\"x\", \"0\");\n    this.foreignObject.setAttribute(\"y\", \"0\");\n    this.foreignObject.setAttribute(\"width\", `${width}`);\n    this.foreignObject.setAttribute(\"height\", `${height}`);\n\n    const sourceClone = sourceNode.cloneNode(true);\n\n    this.foreignObject.appendChild(sourceClone);\n  }\n\n  render(monitor: DragDropMonitor) {\n    const container = this.container;\n    if (container == null) return;\n\n    const offset = monitor.getSourceClientOffset();\n    if (offset == null) return;\n    if (!monitor.isDragging()) return;\n\n    container.style.position = \"fixed\";\n    container.style.left = `${offset.x + 30}px`;\n    container.style.top = `${offset.y + 15}px`;\n  }\n\n  clear() {\n    if (this.foreignObject == null) return;\n    this.foreignObject.innerHTML = \"\";\n  }\n}\n","import { XYCoord } from \"dnd-core\";\n\nexport default function getNodeClientOffset(node: HTMLElement | null | undefined): XYCoord {\n  if (node == null) return { x: 0, y: 0 };\n\n  const el = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n  if (!el) return { x: 0, y: 0 };\n\n  const { top, left } = el.getBoundingClientRect();\n  return { x: left, y: top };\n}\n","export default function stopEvent(event: KeyboardEvent) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n","import type DragAnnouncer from \"./DragAnnouncer\";\nimport type DragPreviewer from \"./DragPreviewer\";\nimport { createFocusManager, FocusManager } from \"./util/FocusManager\";\nimport getNodeClientOffset from \"./util/getNodeClientOffset\";\nimport stopEvent from \"./util/stopEvent\";\n\nimport type { DragDropActions, DragDropManager, DragDropMonitor } from \"dnd-core\";\n\nenum NavigationKeys {\n  UP = \"ArrowUp\",\n  DOWN = \"ArrowDown\",\n  DROP = \"Shift\",\n  CANCEL = \"Escape\",\n}\n\nexport class DropTargetNavigator {\n  private currentHoveredNode: HTMLElement | null;\n  private focusManager: FocusManager;\n  private actions: DragDropActions;\n  private monitor: DragDropMonitor;\n\n  constructor(\n    sourceNode: HTMLElement,\n    private targetNodes: Map<string, HTMLElement>,\n    private manager: DragDropManager,\n    private previewer: DragPreviewer,\n    private announcer: DragAnnouncer,\n  ) {\n    this.currentHoveredNode = sourceNode;\n    this.focusManager = createFocusManager({\n      getFocusableElements: () => this.getViableTargets(targetNodes),\n    });\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n\n    window.addEventListener(\"keydown\", this.handleDraggedElementKeyDown, { capture: true });\n  }\n\n  disconnect() {\n    window.removeEventListener(\"keydown\", this.handleDraggedElementKeyDown, { capture: true });\n  }\n\n  handleDraggedElementKeyDown = (event: KeyboardEvent) => {\n    switch (event.key) {\n      case NavigationKeys.UP:\n        stopEvent(event);\n        this.hoverNode(this.getPreviousDropTarget());\n        return;\n\n      case NavigationKeys.DOWN:\n        stopEvent(event);\n        this.hoverNode(this.getNextDropTarget());\n        return;\n    }\n  };\n\n  hoverNode(node: HTMLElement | null) {\n    const targetId = Array.from(this.targetNodes.entries()).find(\n      ([_key, value]) => node === value,\n    )?.[0];\n    if (targetId == null) return;\n\n    this.actions.hover([targetId], { clientOffset: getNodeClientOffset(node) });\n    this.currentHoveredNode = node;\n    this.previewer.render(this.monitor);\n    this.announcer.announceHover(node, targetId);\n    node?.focus();\n  }\n\n  getNextDropTarget() {\n    return this.focusManager.getNextFocusableElement({\n      wrap: false,\n      from: this.currentHoveredNode ?? undefined,\n    });\n  }\n\n  getPreviousDropTarget() {\n    return this.focusManager.getPreviousFocusableElement({\n      wrap: false,\n      from: this.currentHoveredNode ?? undefined,\n    });\n  }\n\n  getViableTargets(nodes: Map<string, HTMLElement>) {\n    const allowedTargets = this.getAllowedTargets(nodes);\n\n    return allowedTargets.sort((a, b) => {\n      if (a === b) return 0;\n\n      const position = a.compareDocumentPosition(b);\n      if (\n        position &\n        (Node.DOCUMENT_POSITION_FOLLOWING | (position & Node.DOCUMENT_POSITION_CONTAINED_BY))\n      )\n        return -1;\n      else if (\n        position &\n        (Node.DOCUMENT_POSITION_PRECEDING | (position & Node.DOCUMENT_POSITION_CONTAINS))\n      )\n        return 1;\n      else return 0;\n    });\n  }\n\n  getAllowedTargets(nodes: Map<string, HTMLElement>) {\n    const sourceType = this.monitor.getItemType();\n    if (sourceType == null) return Array.from(nodes.values());\n\n    return Array.from(nodes).reduce((acc, [id, node]) => {\n      if (this.manager.getMonitor().canDropOnTarget(id)) acc.push(node);\n      return acc;\n    }, [] as HTMLElement[]);\n  }\n}\n","export interface FocusManagerOptions {\n  getFocusableElements(): HTMLElement[];\n}\n\nexport interface FocusOptions {\n  wrap?: boolean;\n  from?: HTMLElement;\n}\n\nexport interface FocusManager {\n  getNextFocusableElement(options?: FocusOptions): HTMLElement | null;\n  getPreviousFocusableElement(options?: FocusOptions): HTMLElement | null;\n  getFirstFocusableElement(): HTMLElement | null;\n  getLastFocusableElement(): HTMLElement | null;\n}\n\nexport function createFocusManager({ getFocusableElements }: FocusManagerOptions): FocusManager {\n  function getNextFocusableElement(options?: FocusOptions): HTMLElement | null {\n    const currentTarget = options?.from || document.activeElement;\n    if (currentTarget == null) {\n      return null;\n    }\n    const elements = getFocusableElements();\n    const nextNode = elements.find((element) => {\n      return !!(\n        currentTarget.compareDocumentPosition(element) &\n        (Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY)\n      );\n    });\n    if (nextNode == null && options?.wrap) {\n      return elements[0] ?? null;\n    }\n    return nextNode as HTMLElement;\n  }\n\n  function getPreviousFocusableElement(options?: FocusOptions): HTMLElement | null {\n    const currentTarget = options?.from || document.activeElement;\n    if (currentTarget == null) {\n      return null;\n    }\n    const elements = getFocusableElements();\n    for (let i = elements.length - 1; i >= 0; i--) {\n      const element = elements[i];\n      if (\n        currentTarget.compareDocumentPosition(element) &\n        (Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINED_BY)\n      ) {\n        return element as HTMLElement;\n      }\n    }\n    if (options?.wrap) {\n      return elements[elements.length - 1] ?? null;\n    }\n    return null;\n  }\n\n  function getFirstFocusableElement(): HTMLElement | null {\n    const elements = getFocusableElements();\n    return elements[0] ?? null;\n  }\n\n  function getLastFocusableElement(): HTMLElement | null {\n    const elements = getFocusableElements();\n    return elements[elements.length - 1] ?? null;\n  }\n\n  return {\n    getNextFocusableElement,\n    getPreviousFocusableElement,\n    getFirstFocusableElement,\n    getLastFocusableElement,\n  };\n}\n","export default function isKeyboardDragTrigger(\n  event: KeyboardEvent,\n  withUntrusted: boolean = false,\n) {\n  // VERY HACK(faulty): react-dnd-multi-backend fires a \"cloned event\" after\n  // transitioning backends. But, that event is only a base Event, not a specialized\n  // KeyboardEvent or MouseEvent, so it doesn't have any of the `.key`, `.metaKey`,\n  // etc. properties on it. Because of that, knowing that this is a trigger can\n  // only be done by looking at the `isTrusted` property, which is false for\n  // custom-constructed events. Eventually, rdmb should fire an appropriate event instead.\n  if (withUntrusted && event.isTrusted === false) return true;\n  return event.key?.toLowerCase() === \"d\" && (event.metaKey || event.ctrlKey) && !event.altKey;\n}\n","import DragAnnouncer from \"./DragAnnouncer\";\nimport DragPreviewer from \"./DragPreviewer\";\nimport { DropTargetNavigator } from \"./DropTargetNavigator\";\nimport getNodeClientOffset from \"./util/getNodeClientOffset\";\nimport isKeyboardDragTrigger from \"./util/isKeyboardDragTrigger\";\nimport stopEvent from \"./util/stopEvent\";\n\nimport type {Announcer} from \"./DragAnnouncer\";\nimport type {\n  Backend,\n  BackendFactory,\n  DragDropActions,\n  DragDropMonitor,\n  Identifier,\n  DragDropManager,\n  Unsubscribe,\n} from \"dnd-core\";\nimport type { AnnouncementMessages } from \"./util/AnnouncementMessages\";\n\nconst Trigger = {\n  DROP: [\" \", \"Enter\"],\n  CANCEL_DRAG: [\"Escape\"],\n};\n\nfunction isTrigger(event: KeyboardEvent, trigger: typeof Trigger[keyof typeof Trigger]) {\n  return trigger.includes(event.key);\n}\n\ninterface KeyboardBackendContext {\n  window?: Window;\n  document?: Document;\n}\n\ninterface KeyboardBackendOptions {\n  onDndModeChanged?: (enabled: boolean) => unknown;\n  isDragTrigger?: (event: KeyboardEvent, isFirstEvent: boolean) => boolean;\n  getAnnouncementMessages?: () => AnnouncementMessages;\n  announcer?: Announcer;\n  previewerClassName?: string;\n}\n\nexport class KeyboardBackend implements Backend {\n  private static isSetUp: boolean;\n  // React-DnD Dependencies\n  private manager: DragDropManager;\n  private actions: DragDropActions;\n  private monitor: DragDropMonitor;\n  private context: KeyboardBackendContext;\n  private options?: KeyboardBackendOptions;\n  // Internal State\n  private sourceNodes: Map<Identifier, HTMLElement>;\n  private sourcePreviewNodes: Map<string, HTMLElement>;\n  private sourcePreviewNodeOptions: Map<string, any>;\n  private targetNodes: Map<string, HTMLElement>;\n  private _navigator: DropTargetNavigator | undefined;\n  public _previewer: DragPreviewer;\n  private _announcer: DragAnnouncer;\n  private _isDragTrigger: (event: KeyboardEvent, isFirstEvent: boolean) => boolean;\n  private _handlingFirstEvent: boolean = false;\n\n  public constructor(\n    manager: DragDropManager,\n    context: KeyboardBackendContext,\n    options?: KeyboardBackendOptions,\n  ) {\n    this.manager = manager;\n    this.actions = manager.getActions();\n    this.monitor = manager.getMonitor();\n    this.context = context;\n    this.options = options;\n    this._isDragTrigger = options?.isDragTrigger ?? isKeyboardDragTrigger;\n\n    this.sourceNodes = new Map();\n    this.sourcePreviewNodes = new Map();\n    this.sourcePreviewNodeOptions = new Map();\n    this.targetNodes = new Map();\n\n    this._previewer = new DragPreviewer(context.document, options);\n    this._announcer = new DragAnnouncer(options);\n  }\n\n  public setup() {\n    if (KeyboardBackend.isSetUp) {\n      throw new Error(\"Cannot have two Keyboard backends at the same time.\");\n    }\n    KeyboardBackend.isSetUp = true;\n\n    this._handlingFirstEvent = true;\n    this.context.window?.addEventListener(\"keydown\", this.handleGlobalKeyDown, { capture: true });\n\n    this._previewer.attach();\n  }\n\n  public teardown() {\n    KeyboardBackend.isSetUp = false;\n    this.context.window?.removeEventListener(\"keydown\", this.handleGlobalKeyDown, {\n      capture: true,\n    });\n    this.endDrag();\n\n    this._previewer.detach();\n    this._announcer.destroy();\n  }\n\n  private handleGlobalKeyDown = (event: KeyboardEvent) => {\n    if (this.monitor.isDragging() && isTrigger(event, Trigger.CANCEL_DRAG)) {\n      this.endDrag(event);\n      const sourceId = String(this.monitor.getSourceId());\n      const sourceNode = this.sourceNodes.get(sourceId);\n      this._announcer.announceCancel(sourceNode ?? null, sourceId);\n    }\n  };\n\n  private setDndMode(enabled: boolean) {\n    this.options?.onDndModeChanged?.(enabled);\n  }\n\n  public profile(): Record<string, number> {\n    return {\n      sourcePreviewNodes: this.sourcePreviewNodes.size,\n      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n      sourceNodes: this.sourceNodes.size,\n    };\n  }\n\n  public connectDragSource(sourceId: string, node: HTMLElement): Unsubscribe {\n    const handleDragStart = this.handleDragStart.bind(this, sourceId);\n\n    this.sourceNodes.set(sourceId, node);\n    node.addEventListener(\"keydown\", handleDragStart);\n    return () => {\n      this.sourceNodes.delete(sourceId);\n      node.removeEventListener(\"keydown\", handleDragStart);\n    };\n  }\n\n  public connectDragPreview(sourceId: string, node: HTMLElement, options: any): Unsubscribe {\n    this.sourcePreviewNodeOptions.set(sourceId, options);\n    this.sourcePreviewNodes.set(sourceId, node);\n    return () => {\n      this.sourcePreviewNodes.delete(sourceId);\n      this.sourcePreviewNodeOptions.delete(sourceId);\n    };\n  }\n\n  public connectDropTarget(targetId: string, node: HTMLElement): Unsubscribe {\n    this.targetNodes.set(targetId, node);\n    node.addEventListener(\"keydown\", this.handleDrop);\n    // Ensure that the target will be focusable by the navigator\n    node.tabIndex = Math.max(-1, node.tabIndex);\n\n    return () => {\n      this.targetNodes.delete(targetId);\n      node.removeEventListener(\"keydown\", this.handleDrop);\n    };\n  }\n\n  private getSourceClientOffset = (sourceId: string) => {\n    return getNodeClientOffset(this.sourceNodes.get(sourceId));\n  };\n\n  private handleDragStart = (sourceId: string, event: KeyboardEvent) => {\n    if (!this._isDragTrigger(event, this._handlingFirstEvent)) return;\n    this._handlingFirstEvent = false;\n\n    if (!this.monitor.canDragSource(sourceId)) return;\n\n    if (this.monitor.isDragging()) {\n      this.actions.publishDragSource();\n      return;\n    }\n\n    stopEvent(event);\n\n    const sourceNode = this.sourceNodes.get(sourceId);\n    if (sourceNode == null) return;\n\n    this._navigator = new DropTargetNavigator(\n      sourceNode,\n      this.targetNodes,\n      this.manager,\n      this._previewer,\n      this._announcer,\n    );\n    this._previewer.createDragPreview(this.sourcePreviewNodes.get(sourceId) ?? sourceNode);\n\n    this.actions.beginDrag([sourceId], {\n      clientOffset: this.getSourceClientOffset(sourceId),\n      getSourceClientOffset: this.getSourceClientOffset,\n      publishSource: false,\n    });\n    this._previewer.render(this.monitor);\n    this.setDndMode(true);\n    this._announcer.announceDrag(sourceNode, sourceId);\n  };\n\n  private handleDrop = (event: KeyboardEvent) => {\n    if (!isTrigger(event, Trigger.DROP)) return;\n\n    const sourceId = String(this.monitor.getSourceId());\n    const sourceNode = this.sourceNodes.get(sourceId);\n    this._announcer.announceDrop(sourceNode ?? null, sourceId);\n\n    this.actions.drop();\n    this.endDrag(event);\n  };\n\n  private endDrag(event?: KeyboardEvent) {\n    event != null && stopEvent(event);\n    this._navigator?.disconnect();\n    this._previewer.clear();\n    if (this.monitor.isDragging()) this.actions.endDrag();\n    this.setDndMode(false);\n  }\n}\n\nconst createKeyboardBackendFactory: BackendFactory = (\n  manager: DragDropManager,\n  context: KeyboardBackendContext,\n  options?: KeyboardBackendOptions,\n) => new KeyboardBackend(manager, context, options);\n\nexport default createKeyboardBackendFactory;\n"],"names":["getNodeDescription","node","getAttribute","innerText","DEFAULT_ANNOUNCEMENT_MESSAGES","pickedUpItem","itemId","droppedItem","hoveredTarget","targetId","canceledDrag","getDefaultAnnouncementMessages","DragAnnouncer","constructor","getAnnouncementMessages","announcer","externalAnnouncer","getMessages","this","LiveAnnouncer","require","announce","clearAnnouncements","clearAnnouncer","destroy","destroyAnnouncer","message","assertiveness","timeout","announceDrag","id","announceHover","announceDrop","announceCancel","clear","DragPreview","document","previewerClassName","container","svg","foreignObject","_this$document","createElement","_this$document2","_this$document3","className","style","cssText","appendChild","attach","body","detach","_this$document5","contains","removeChild","createDragPreview","sourceNode","width","height","getBoundingClientRect","setAttribute","sourceClone","cloneNode","render","monitor","offset","getSourceClientOffset","isDragging","position","left","x","top","y","innerHTML","getNodeClientOffset","el","nodeType","Node","ELEMENT_NODE","parentElement","stopEvent","event","preventDefault","stopImmediatePropagation","NavigationKeys","DropTargetNavigator","targetNodes","manager","previewer","currentHoveredNode","focusManager","actions","handleDraggedElementKeyDown","key","UP","hoverNode","getPreviousDropTarget","DOWN","getNextDropTarget","getFocusableElements","getNextFocusableElement","options","currentTarget","from","activeElement","elements","nextNode","find","element","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_CONTAINED_BY","wrap","getPreviousFocusableElement","i","length","DOCUMENT_POSITION_PRECEDING","getFirstFocusableElement","getLastFocusableElement","createFocusManager","getViableTargets","getActions","getMonitor","window","addEventListener","capture","disconnect","removeEventListener","Array","entries","_key","value","_Array$from$find","hover","clientOffset","focus","undefined","nodes","getAllowedTargets","sort","a","b","DOCUMENT_POSITION_CONTAINS","getItemType","values","reduce","acc","canDropOnTarget","push","isKeyboardDragTrigger","withUntrusted","isTrusted","toLowerCase","metaKey","ctrlKey","altKey","Trigger","isTrigger","trigger","includes","KeyboardBackend","context","sourceNodes","sourcePreviewNodes","sourcePreviewNodeOptions","_navigator","_previewer","_announcer","_isDragTrigger","_handlingFirstEvent","handleGlobalKeyDown","endDrag","sourceId","String","getSourceId","get","handleDragStart","canDragSource","publishDragSource","beginDrag","publishSource","setDndMode","handleDrop","drop","isDragTrigger","Map","DragPreviewer","setup","isSetUp","Error","teardown","enabled","onDndModeChanged","profile","size","connectDragSource","bind","set","delete","connectDragPreview","connectDropTarget","tabIndex","Math","max","createKeyboardBackendFactory"],"mappings":"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"}